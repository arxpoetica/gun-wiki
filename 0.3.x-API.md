---------------------------------------------------------------------

***Please post documentation comments, questions, and suggestions to
[[issue #70|https://github.com/amark/gun/issues/70]].***

---------------------------------------------------------------------

> **This page is currently being written**

**Table of Contents**
 - [Gun constructor](#gunoptions)
 - [gun.put](#gunputdata-callback)
   - [accepted values](#allowed-types)
   - [callback](#callbackerror-success)
   - [examples](#examples-1)
   - [chain](#chain-context)
 - [gun.key](#gunkeyname)
   - [name](#name)
   - [callback](#callbackerror-success-1)
   - [options](#options)
   - [examples](#examples-1)
 - [gun.get](#gungetkey)

# Gun(options)
Used to creates a new gun database instance.

```javascript
var db = new Gun(options)
```
> **note:** `Gun` works with or without the `new` operator.

## Options

 - `no params/undefined` creates a local datastore using the default persistence layer, either localStorage or a JSON file.

 - passing an `array` of URLs creates a local datastore, and attempts to sync it with each peer at the addresses.

   - when only syncing with a single peer, you can leave out the array, sending in just a `string`.

 - `{ peers, wire, uuid... }` the previous options are actually aggregated into an `object` under the hood.

   - `options.peers` is an object, where the URLs are properties, and the value is an empty object.

   - `options.wire` allows you to manually override module hooks for `put` and `get`
     (however, gun exposes a more streamlined approach for building extensions and modules).

   - `options.uuid` allows you to override the default 24 random alphanumeric soul generator with
      your own function.

   - `options['module name']` allows you to pass options to a 3rd party module. Their project README
     will likely list the exposed options.
     [Here is a list of such modules...](https://github.com/amark/gun/wiki#modules)

   - `options.init` is a boolean that tells the system whether you want to implicitly create
	   data if it doesn't exist.

### Examples
Sync with one peer
```javascript
new Gun('http://yourdomain.com/gun')
```

Sync with many peers
```javascript
new Gun(['http://server1.com', 'http://server2.com'])
```

Working with modules
```javascript
new Gun({
  // Amazon S3 (comes bundled)
  s3: {
    key: '',
    secret: '',
    bucket: ''
  },

  // simple JSON persistence (bundled)
  // meant for ease of getting started
  // NOT meant for production
  file: 'file/path.json'
})
```

Advanced options
```javascript
new Gun({
  // set your own UUID function
  uuid: function () {...},

  // set your own get/put handlers
  wire: {
    get: getHandler,
    put: putHandler
  },

  // disable implicit collections
  init: false
})
```
---------------------------------------------------------
# gun.put(data, callback)
Save data into gun, syncing it with your connected peers.

It has two parameters, and only the first is required:

 1. the `data` to save
 2. an optional `callback`, invoked on each acknowledgment

`gun.put(data, callback)`

## Allowed types

`.put` restricts the input to a specific subset:

 - `objects`:
   [partial](https://github.com/amark/gun/wiki/Partials-and-Circular-References#),
   [circular](https://github.com/amark/gun/wiki/Partials-and-Circular-References#circular-references), and nested
 - `strings`
 - `numbers`
 - `booleans`
 - `null`

Gun will refuse `undefined`, `NaN`, `Infinity`, and `arrays`.

> Traditional arrays are dangerous in real-time apps

## Callback(error, success)
  
The `callback` is fired each time a peer responds with an error or successful persistence message, including the local cache. Acknowledgement can be slow, but the write propagates across networks as fast as the pipes connecting them.

If the error argument is undefined, then the operation succeeded, although the exact values are left up to the module developer.

## Examples

Saving objects
```javascript
gun.path('propertyName').put({
  key: 'value',
  object: {
    nested: true
  }
})
```

Saving primitives
```javascript
// strings
gun.path('name.first').put('Dave')

// numbers
gun.path('temperature').put(58.6)

// booleans
gun.path('enabled').put(true)
```

Using the callback
```javascript
gun.path('survey.submission').put(submission, function (err) {
  if (err) {
    return ui.show.error(err)
  }
  ui.show.success(true)
})
```

## Chain context
`gun.put` does not change the gun context.
```javascript
gun.path('key').put(value) == gun.path('key')
```

# gun.key(name)
Index your data, so you can find it later.

We can think of keys as groups, categories, or tags that we associate with a node, and each node can belong to more than one tag. Keys are one of gun's most powerful features.

The `.key` method takes 3 arguments, and only the first is required:
 - the `name` of the category to join under
 - the `callback` to invoke on each acknowledgment
 - `options` for configuration

## Name
A string representing the name of a group to attach a node to. Common practice is to namespace your keys into routes: `.key('users/cities/Provo')`

> **note:** keys are case sensitive

## Callback(error, success)
The same behavior as the callback in [gun.put](callbackerror-success).

## Options
Pass a node's `UUID`/`soul` as the third argument to ignore the context, and attach the key directly to the soul.

# gun.get(key)
Retrieve all data under that [key](gunkeyname), saving it to local persistence.

It takes three parameters: `keyName`, `callback`, and `options`, although you'll almost never need `callback` or `options`.

 - `key` is the name of the group you want to get (see [naming with gun.key](gunkeyname)).