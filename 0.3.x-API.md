---------------------------------------------------------------------

***Please post documentation comments, questions, and suggestions to
[[issue #70|https://github.com/amark/gun/issues/70]].***

---------------------------------------------------------------------

> **This page is currently being written**

**Table of Contents**
 - [Gun constructor](#Gun)
 - [gun.put](#put)
   - [accepted values](#allowed-types)
   - [callback](#callbackerror-success)
   - [examples](#examples-1)
   - [chain](#chain-context)
 - [gun.key](#key)
   - [name](#name)
   - [callback](#callbackerror-success-1)
   - [options](#options-1)
   - [examples](#examples-2)
   - [chain](#chain-context-1)
 - [gun.get](#get)
   - [name](#name-1)
   - [callback](#callbackerror-graph)
   - [options](#options-2)
   - [examples](#examples-3)
   - [chain](#chain-context-2)

# <a name="Gun"></a>Gun(options)
Used to creates a new gun database instance.

```javascript
var db = new Gun(options)
```
> **note:** `Gun` works with or without the `new` operator.

## Options

 - `no params/undefined` creates a local datastore using the default persistence layer, either localStorage or a JSON file.

 - passing an `array` of URLs creates a local datastore, and attempts to sync it with each peer at the addresses.

   - when only syncing with a single peer, you can leave out the array, sending in just a `string`.

 - `{ peers, wire, uuid... }` the previous options are actually aggregated into an `object` under the hood.

   - `options.peers` is an object, where the URLs are properties, and the value is an empty object.

   - `options.wire` allows you to manually override module hooks for `put` and `get`
     (however, gun exposes a more streamlined approach for building extensions and modules).

   - `options.uuid` allows you to override the default 24 random alphanumeric soul generator with
      your own function.

   - `options['module name']` allows you to pass options to a 3rd party module. Their project README
     will likely list the exposed options.
     [Here is a list of such modules...](https://github.com/amark/gun/wiki#modules)

   - `options.init` is a boolean that tells the system whether you want to implicitly create
	   data if it doesn't exist.

### Examples
Sync with one peer
```javascript
new Gun('http://yourdomain.com/gun')
```

Sync with many peers
```javascript
new Gun(['http://server1.com', 'http://server2.com'])
```

Working with modules
```javascript
new Gun({
  // Amazon S3 (comes bundled)
  s3: {
    key: '',
    secret: '',
    bucket: ''
  },

  // simple JSON persistence (bundled)
  // meant for ease of getting started
  // NOT meant for production
  file: 'file/path.json'
})
```

Advanced options
```javascript
new Gun({
  // set your own UUID function
  uuid: function () {...},

  // set your own get/put handlers
  wire: {
    get: getHandler,
    put: putHandler
  },

  // disable implicit collections
  init: false
})
```
---------------------------------------------------------
<h1><a name="put"></a>gun.put(data, callback)</h1>
Save data into gun, syncing it with your connected peers.

It has two parameters, and only the first is required:

 1. the `data` to save
 2. an optional `callback`, invoked on each acknowledgment

`gun.put(data, callback)`

## Allowed types

`.put` restricts the input to a specific subset:

 - `objects`:
   [partial](https://github.com/amark/gun/wiki/Partials-and-Circular-References#),
   [circular](https://github.com/amark/gun/wiki/Partials-and-Circular-References#circular-references), and nested
 - `strings`
 - `numbers`
 - `booleans`
 - `null`

Gun will refuse `undefined`, `NaN`, `Infinity`, and `arrays`.

> Traditional arrays are dangerous in real-time apps

## Callback(error, success)
  
The `callback` is fired each time a peer responds with an error or successful persistence message, including the local cache. Acknowledgement can be slow, but the write propagates across networks as fast as the pipes connecting them.

If the error argument is undefined, then the operation succeeded, although the exact values are left up to the module developer.

## Examples

Saving objects
```javascript
gun.path('propertyName').put({
  key: 'value',
  object: {
    nested: true
  }
})
```

Saving primitives
```javascript
// strings
gun.path('name.first').put('Dave')

// numbers
gun.path('temperature').put(58.6)

// booleans
gun.path('enabled').put(true)
```

Using the callback
```javascript
gun.path('survey.submission').put(submission, function (err) {
  if (err) {
    return ui.show.error(err)
  }
  ui.show.success(true)
})
```

## Chain context
`gun.put` does not change the gun context.
```javascript
gun.path('key').put(value) == gun.path('key')
```

--------------------------------------------------
# <a name="key"></a>gun.key(name)
Index your data, so you can find it later, faster.

We can think of keys as groups, categories, or tags that we associate with a node, and each node can belong to more than one tag. Keys are one of gun's most powerful features.

The `.key` method takes 3 arguments, and only the first is required:
 - the `name` of the category to join under
 - the `callback` to invoke on each acknowledgment
 - `options` for configuration

## Name
A string representing the name of a group to attach a node to. Common practice is to namespace your keys into routes: `.key('users/cities/Provo')`

> **note:** keys are case sensitive

## Callback(error, success)
The same behavior as the callback in [gun.put](#put).

## Options
Ignore the chain context, tagging a node directly by it's soul.
```javascript
// find node by soul "Zwl6..." and tag it under "examples"
gun.key('examples', null, 'Zwl6PaS4oo7Ivt21X5bU0nds')
```

## Examples
Indexing data for faster lookup

```javascript
var interests = groupName + '/members/interests'

// each member
gun.get(groupName).path('members').map(function (member) {
  // group each member's interests together
  this.path('interests').key(interests)
})

// each member's interests
// now indexed into a single group
gun.get(interests)
```

Tagging data
```javascript
gun.get(groupName).path('members').put({
  [memberID]: {
    nickname: 'Berners-Lee',
    interests: {...}
  }
}).key(groupName + '/members')
```

## Chain context
`gun.key` does not change the context.
```javascript
gun.path('node').key('nodes') === gun.path('node')
```

------------------------------------------------------------------------------------------
# <a name="get"></a>gun.get(name)
Load all data under that [key](#key) into the context, and saving it to local persistence.

It takes three parameters:

 - `keyName`
 - `callback`
 - `options`

You'll almost never need to use the `callback` or `options` parameters, unless you're building bare-metal extensions.

## Name
The [`keyName`](#key) string is the name of the group you want to get. If gun can't find the key, it's implicitly initialized as an empty object.

```javascript
gun.get(existingData).put({ property: 'value' })
/*
  {
    data: ...,
    property: 'value',
    data: ...
  }
*/

gun.get(nonExistentKey).put({ property: 'value' })
// { property: 'value' }
```

## Callback(error, graph)
The callback is a listener for errors and raw graph data. It may be called multiple times for a single request, since gun uses a streaming architecture.

> The callback is exposed for bare-metal extensions. Most developers will never need it.

```javascript
gun.get(key, function (error, graph) {
  // called many times
})
```

## Options
Currently one option is standardized: force gun to draw from persistence, not memory.

```javascript
// read from storage, not memory
gun.get(key, null, {
  force: true
})
```

## Examples

Retrieving a key
```javascript
// retrieve all available seats
gun.get('seats/available').map(ui.show.seats)
```

Using the callback
```javascript
gun.get('notifications', function (error, graph) {
  if (error) ui.show.error(error)
  server.latency.log(new Date)
})
```

## Chain context
After calling `gun.get`, the chain context refers to the data you requested, regardless of what happened before calling `gun.get`.

```javascript
gun.get('materials').get('users') === gun.get('users')
```
