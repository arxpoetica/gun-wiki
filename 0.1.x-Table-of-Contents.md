 >NOTE: v0.1.0 is depreciated, but here are the old docs for it:  
---  


##### Table of Contents
 - [Basic Wire Protocol methods](Wire-Protocols-(v0.1.x)) :arrow_upper_right: 
 - [Internals](#Internals)
 - [Middleware Plugin Hooks](#middleware-plugin-hooks)
 - [Setting Data](Setting-Data-(v0.1.x)) :arrow_upper_right: 
 - [Getting Data](#Getting-Data)
 - [Reactive and Chainable API](#Reactive-and-Chainable-API)
 - [Porting GUN](Porting-GUN) :arrow_upper_right: 
 - [Partials and Circular References](Partials-and-Circular-References-(v0.1.x)) :arrow_upper_right: 

--- 


# 0.1.0 API and How to:

### Basic [[Wire Protocol|Wire-Protocols-(v0.1.x)]] methods

## Internals
- **set**, writes to `this._.node`, if `this._.keys` exists then links them to it.
- **key**, writes to `this._.keys`, if `this._.node` exists then links them to it.


- **load**, pulls `this._.node` in from cache or remote, via a key or a soul, and links.
- **get**, reads from `this._.field` on `this._.node` or the node itself.


**path** wraps load recursively, to traverse depth, and writes `this._.field`.

**on** emulates get, but over time as changes are made.

**map** wraps around parallel paths.

**blank** is a conditional which executes if the node from load is empty.

**insert** wraps around set, putting in objects without human friendly fields, may not stay in core.

## Middleware Plugin Hooks
- **load**, is responsible for retrieving a node from non-memory storage. Whether it be from disk, peers, another database, or a cloud service, it all must conform to the following API.
    - **key**, _text or object_, your load hook will receive a key string (_"my/first/data"_) or a soul meta object (_{'#': 'UfAve0cVP1e51PE20hqpN8y9'}_) as the first parameter.
    - **function**, is a callback you need to pass the data too.
        - **err**, _error object_, a regular javascript object that has an `err` field on it.
        - **node**, _null or node_, if the object does not exist at this layer, return `null`, else return the node.
- key...


### [[Setting Data|Setting-Data-(v0.1.x)]]


## Getting Data

Now that we've looked at setting values in gun, let's look at retrieving them again. For starters, let's go get Cecil out of the database. If you haven't gone over the setting values, [you probably want to start there](Setting-Data-(v0.1.x)).

```javascript
gun.load('person/cecil').get(function(cecil) {
    console.log(cecil.location); // Prints `Night Vale` to the console
});
```

To explain the different methods going on here, `.load(__key__)` gives us access to a particular "key" in gun, and then `.get()` takes a callback that will have the value passed to it as a parameter. Once you've loaded a key, you can also tell gun to "step inside" that object and return an associated object. For example, we can easily get Khoshekh through Cecil by using `.path()`

```javascript
gun.load('person/cecil').path('cat').get(function(khoshekh) {
    console.log(khoshekh.species); // Prints `cat` to the console
});
```

## Reactive and Chainable API

At its core, gun is just a synchronization protocol - but that is boring and useless by itself. So I've implemented a really exciting and easy API for you to use. If you don't like my approach or naming convention, you can simply rename things yourself or better yet fork the project and build a beautifully custom API and everything will still work via the protocol.


#### API
Because of the [approach](#approach), you can do a lot of neat combinations in GUN.

 - You can save a reference to an object and reuse it later from that context:
```javascript
var mark = gun.set({name: "Mark Nadal"});
var name = mark.path('name');
mark.get(function(user){
  console.log(user); // {name: "Mark Nadal"}
});
name.get(function(val){
  console.log(val); // "Mark Nadal"
});
```
 - You can path into a field to do something, and then go back:
```javascript
mark.set({ spouse: {name: "Amber Nadal"}, cat: {name: "Hobbes"} })
  .path('spouse')
    .set({studies: "Psychology"})
    .back
  .path('cat.name')
    .get(function(name){
      console.log(name); // "Hobbes"
});
```

#### Approach
- If you are unfamiliar with **reactive** programming, it is a code structure that emphasizes vertical readability by avoiding nested loops and callbacks. Instead of doing
```javascript
// ugly
for(var i = 0; i < PDFs.length; i += 1){
	var fileName = PDFs[i];
	readFromDisk(filename, function(file){
		var pages = splitIntoPages(file);
		for(var j = 0; j < pages.length; j += 1){
			var page = pages[j];
			saveToFolder('page' + j, page, function(err, done){
				console.log("Done! If no," err);
			});
		}
	});
}
```
you can simplify to something more clearer and reusable
```javascript
var PDF = {};
PDF.read = function(fileName){
	readFromDisk(filename, PDF.split);
}
PDF.split = function(file){
	splitIntoPages(file).forEach(PDF.save);
}
PDF.save = function(page, number){
	saveToFolder('page' + number, page, PDF.done);
}
PDF.done = function(err, done){
	console.log("Done! If no," err);
}
PDFs.forEach(PDF.read);
```
- If you are unfamiliar with **chaining**, it is an API style that allows you to zoom into a context without having to create new variables. So rather than doing
```javascript
// ugly
var page = document.getElementById("page");
var child = page.firstElementChild;
child.style.background = "blue";
child.style.color = "green";
child.addEventListener('click', function(event){
  console.log("hello world!");
}, true);
```
you can just do
```javascript
$('#page')
	.children()
	.first()
	.css("background", "blue")
	.css("color", "green")
	.on("click", function(event){
		console.log("hello world");
	});
```


### [[Porting GUN|Porting-GUN]] to a new language


### [[Partials and Circular References|Partials-and-Circular-References-(v0.1.x)]]